; Display management routines.
;
; * Horizontal character scrolling (with DMA Delay).
; * Horizontal smooth scrolling.
; * TODO: Sprite multiplexer.
; * TODO: Frame counter.

.scope screen {
	IRQ1_LINE = 242
	IRQ2_LINE = 45
	
	.export init: {
		; Detect PAL/NTSC
		{
			lda vic.raster
			{
				cmp vic.raster
				beq _cont
			}
			bmi _cont
			
			cmp #$06
			beq ntsc_263
			
			cmp #$05
			beq ntsc_262
			
			; PAL
			; 312 raster lines
			; 63 cycles per line
			lda #$80 ; illegal opcode NOP Immediate
			sta isr3.ntsc_pal_patch_1
			sta isr3.ntsc_pal_patch_2
			jmp _break
			
			; NTSC
			; 263 raster lines
			; 65 cycles per line
			ntsc_263:
			jmp _break
			
			; NTSC
			; 262 raster lines
			; 64 cycles per line
			ntsc_262:
			lda #$04 ; illegal opcode NOP ZeroPage
			sta isr3.ntsc_pal_patch_1
			sta isr3.ntsc_pal_patch_2
		}
		
		; Set up raster IRQ
		php
		sei
		lda #<isr1
		sta irq
		lda #>isr1
		sta irq + 1
		lda vic.cr1
		and #$7f
		sta vic.cr1
		lda #IRQ1_LINE
		sta vic.raster
		inc vic.irqmask
		plp
		
		rts
	}
	
	; Raster ISR, fires on line 242
	isr1: {
		; Save accumulator
		pha
		
		; Disable screen
		lda #$7b
		sta vic.cr1
		
		; Set up next raster IRQ in chain
		lda #<isr2
		sta irq
		lda #>isr2
		sta irq + 1
		lda #IRQ2_LINE
		sta vic.raster
		
		; Ack IRQ and re-enable interrupts
		lda #1
		sta vic.irqstatus
		cli
		
		; Restore accumulator and return
		pla
		rti
	}
	
	isr2: {
		; Save registers
		pha ; 2
		txa ; 5
		pha ; 8
		tya ; 10
		pha ; 13
		
		; Set up another raster IRQ for the next line
		lda #<isr3 ; 15
		sta irq ; 19
		lda #>isr3 ; 21
		sta irq+1 ; 25
		inc vic.raster ; 31
		
		; Acknowledge the IRQ
		inc vic.irqstatus; 37
		
		; Save the stack pointer
		tsx ; 39
		
		; Enable IRQs
		cli ; 41
		
		; nop until the next IRQ
		{
			nop ; 43
			nop ; 45
			nop ; 47
			nop ; 49
			nop ; 51
			nop ; 53
			nop ; 55
			nop ; 57
			nop ; 59 (IRQ should have happened by now)
			jmp _cont ; compatibility with freezer carts
		}
	}

	.align $100 $??
	.scope isr3 {
		; Restore the stack pointer saved by isr2
		txs ; 2
		
		; Set pixel scroll position
		lda x ; 6
		and #$07 ; 8
		sta vic.cr2 ; 12
		
		; Delay 39/40/41 cycles
		ldx #5
		{
			dex ; 2
			bne _cont ; 3/2
		}
		.global ntsc_pal_patch_1:
		nop
		nop
		nop
		nop
		nop
		
		; Correct for 1-cycle wobble
		lda vic.raster
		cmp vic.raster
		{ beq _break }
		
		lda #$11
		sta vic.cr1
		
		; Calculate the character scroll position (x / 8)
		char_x=3
		lda x+1 ; 4
		lsr ; 6
		sta char_x+1 ; 9
		lda x ; 13
		ror ; 15
		sta char_x ; 18
		lsr char_x+1 ; 23
		ror char_x ; 28
		lsr char_x+1 ; 33
		ror char_x ; 38
		
		; Calculate a variable delay by branching over nops.
		; The delay is accurate to 2 cycles.
		lda #39 ; 40
		sec ; 42
		sbc char_x ; 45
		lsr ; 47
		sta x_branch_offset ; 51
		
		; Introduce an additional 1-cycle delay if the LSB of the x
		; offset is set.
		{ bcc _break }
		
		; Branch somewhere into the nops depending on the x offset.
		{ clv }
		x_branch_offset = * + 1
		bvc *
		nop
		nop
		nop
		nop
		nop
		nop
		nop
		nop
		nop
		nop
		nop
		nop
		nop
		nop
		nop
		nop
		nop
		nop
		nop
		
		; Here is the furthest that bvc will ever branch
		
		; Patchable 2/3/4 cycle delay for NTSC/PAL compatibility
		.global ntsc_pal_patch_2:
		nop
		nop
		
		; Do the DMA Delay by tweaking vic.cr1 at the correct time
		lda #%01111011
		dec vic.cr1
		inc vic.cr1
		sta vic.cr1
		
		; Acknowledge the IRQ
		lda #1
		sta vic.irqstatus
		
		; Enable screen
		lda #$1b
		sta vic.cr1
		
		; Scroll at a constant rate for now.
		inc x
		{
			bne _break
			inc x+1
		}
		{
			lda #1
			cmp x+1
			bne _break
			lda #64
			cmp x
			bne _break
			lda #0
			sta x
			sta x+1
		}
		
		; Set up next raster IRQ in chain
		lda #<isr1
		sta irq
		lda #>isr1
		sta irq + 1
		lda #IRQ1_LINE
		sta vic.raster
		
		; Increment frame counter
		{
			ldx frame
			cpx #$ff
			beq _break
			inx
			stx frame
		}
		
		; Restore registers
		pla
		tay
		pla
		tax
		pla
		
		rti
	}
	
	x: .buf 2
	.global frame = 4
}
